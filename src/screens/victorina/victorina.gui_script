
local monarch = require 'monarch.monarch'
local button = require 'common.button'
local victorina = require 'screens.victorina.victorina'

local EMPTY_STR = ''
local WHITE_COLOR = vmath.vector4(1, 1, 1, 1)
local NULL_COLOR = vmath.vector4(1, 1, 1, 0)
local RED_COLOR = vmath.vector4(1, 39/255, 93/255, 1)
local LIGHT_RED_COLOR = vmath.vector4(254/255, 182/255, 182/255, 1)
local GREEN_COLOR = vmath.vector4(166/255, 1, 0, 1)

local attempt_points = {4,3,2,1}

local faces = {
	[1] = {
		normal = 'f_normal',
		happy = 'f_happy',
		sad = 'f_sad',
	},
	[2] = {
		normal = 'm_normal',
		happy = 'm_happy',
		sad = 'm_angry',
	}
}


local function set_score(self)
	gui.set_text(self.score_m, self.score[2])
	gui.set_text(self.score_f, self.score[1])
end

local function set_face(node, state)
	gui.set_enabled(node, state)
	if state then
		gui.play_flipbook(node, state)
	end
end

local function show_question(self)
	local question = self.question
	gui.set_text(self.question_text, question.question)
	gui.set_text(self.move_title, self.side == 1 and 'Ход Вероники' or 'Ход Антона')

	for index, answer in ipairs(self.answers) do
		gui.cancel_animation(answer.icon, gui.PROP_COLOR)
		gui.set_color(answer.icon, WHITE_COLOR)
		gui.set_text(answer.text, question.options[index])
		answer.picked = false
	end
	gui.set_enabled(self.question_image, question.image_url and question.image_url ~= EMPTY_STR)
	if question.image_url and question.image_url ~= EMPTY_STR then
		gui.play_flipbook(self.question_image, question.image_url)
	end
	gui.set_enabled(self.hide, question.hide)
	if question.hide then
		gui.cancel_animation(self.hide, 'color.w')
		gui.set(self.hide, 'color.w', 1)
		gui.set_scale(self.hide, vmath.vector3(question.scale or 1))
		gui.set_position(self.hide, vmath.vector3(question.hide[1], question.hide[2], 0))
		gui.animate(self.hide, 'scale', (question.scale or 1) * 1.1, gui.EASING_LINEAR, 1, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
	end

	for i = 1, 3 do
		gui.set_enabled(self['hide' ..i], question['hide' ..i])
		if question['hide' ..i] then
			gui.cancel_animation(self['hide' ..i], 'color.w')
			gui.set(self['hide' ..i], 'color.w', 1)
			gui.set_scale(self['hide' ..i], vmath.vector3(question['scale' .. i] or 1))
			gui.set_position(self['hide' ..i], vmath.vector3(question['hide' ..i][1], question['hide' ..i][2], 0))
			gui.animate(self['hide' ..i], 'scale', (question['scale' .. i] or 1) * 1.1, gui.EASING_LINEAR, 1, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
		end
	end
	
end

local function happy_anim(self, side)
	set_face(self.pers[side].face,faces[side].happy)
	gui.animate(self.pers[side].root, 'position.y', gui.get_position(self.pers[side].root).y + 20, gui.EASING_LINEAR, 0.5, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
end

local function angry_anim(self, side)
	set_face(self.pers[side].face,faces[side].sad)
	gui.animate(self.pers[side].root, 'position.x', gui.get_position(self.pers[side].root).x - 5, gui.EASING_LINEAR, 0.05, 0, function ()
		gui.animate(self.pers[side].root, 'position.x', gui.get_position(self.pers[side].root).x + 5, gui.EASING_LINEAR, 0.1, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
	end)
	gui.set_color(self.pers[side].face, LIGHT_RED_COLOR)
end

local function set_default(self)
	set_face(self.pers[1].face, faces[1].normal)
	set_face(self.pers[2].face, faces[2].normal)
	gui.cancel_animation(self.pers[1].root, 'position')
	gui.cancel_animation(self.pers[2].root, 'position')
	gui.animate(self.pers[1].root, 'position.y', self.pers[1].pos.y + 3, gui.EASING_LINEAR, 3, 0, nil, gui.PLAYBACK_LOOP_PINGPONG)
	gui.animate(self.pers[2].root, 'position.y', self.pers[2].pos.y + 3, gui.EASING_LINEAR, 3, 1.5, nil, gui.PLAYBACK_LOOP_PINGPONG)
	gui.set_position(self.pers[1].root, self.pers[1].pos)
	gui.set_position(self.pers[2].root, self.pers[2].pos)
	gui.set_color(self.pers[1].face, WHITE_COLOR)
	gui.set_color(self.pers[2].face, WHITE_COLOR)
end

local function on_answer(self, answer_index)
	msg.post('.', 'release_input_focus')
	local answer = self.answers[answer_index]
	if self.question.answer == answer_index then
		happy_anim(self, self.side)
		angry_anim(self, self.side == 1 and 2 or 1)
		gui.set_text(self.question_text, self.question.explanation)
		gui.animate(answer.icon, gui.PROP_COLOR, GREEN_COLOR, gui.EASING_OUTCIRC, 0.5, 0, nil, gui.PLAYBACK_ONCE_FORWARD)
		gui.animate(self.hide, 'color.w', 0, gui.EASING_LINEAR, 0.3, 0)
		gui.animate(self.hide1, 'color.w', 0, gui.EASING_LINEAR, 0.3, 0)
		gui.animate(self.hide2, 'color.w', 0, gui.EASING_LINEAR, 0.3, 0)
		gui.animate(self.hide3, 'color.w', 0, gui.EASING_LINEAR, 0.3, 0)
		
		self.score[self.side] = self.score[self.side] + attempt_points[self.attempt]
		self.side = self.side == 1 and 2 or 1
		self.attempt = 1
		set_score(self)
		
		timer.delay(2, false, function()
			if self.question.replace_to then
				gui.play_flipbook(self.question_image, self.question.replace_to)
			end
			set_default(self)
			self.question_index = self.question_index + 1
			if self.questions[self.question_index] then
				self.question = self.questions[self.question_index]

				for index, answer in ipairs(self.answers) do
					gui.animate(answer.button.node, gui.PROP_COLOR, NULL_COLOR, gui.EASING_LINEAR, 0.5, 0, function ()
						answer.button:disable()
						self.next_question:enable()
						msg.post('.', 'acquire_input_focus')
					end)

				end
				
				-- show_question(self)
			else
				-- НА ФИНАЛЬНЫЙ ЭКРАН ДОБАВИТЬ РАВНОЕ КОЛВО ОЧКОВ И УРА ВЫ ИДЕАЛЬНО ДРУГ ДРУГА ЗНАЕТЕ
				monarch.show(monarch.scr.final, nil, {score = self.score})
			end

			-- set_default(self)
			gui.cancel_animation(self.hide, 'scale')
		end)
	else
		happy_anim(self, self.side == 1 and 2 or 1)
		angry_anim(self, self.side)
		self.attempt = self.attempt + 1
		self.answers[answer_index].picked = true
		gui.animate(answer.icon, gui.PROP_COLOR, RED_COLOR, gui.EASING_OUTCIRC, 0.5, 0, nil, gui.PLAYBACK_ONCE_FORWARD)
		timer.delay(1.2, false, function()
			-- show_question(self)
			msg.post('.', 'acquire_input_focus')
			set_default(self)
		end)
	end
end

local function init_nodes(self)
	self.question_text = gui.get_node('question')
	self.question_image = gui.get_node('image')
	self.score_m = gui.get_node('score_m')
	self.score_f = gui.get_node('score_f')
	self.hide = gui.get_node('hide')
	self.hide1 = gui.get_node('hide1')
	self.hide2 = gui.get_node('hide2')
	self.hide3 = gui.get_node('hide3')
	self.move_title = gui.get_node('move_title')
	self.next_question = button.new(nil, 'next', function()
		show_question(self)
		self.next_question:disable()
		for index, answer in ipairs(self.answers) do
			answer.button:enable()
			gui.animate(answer.button.node, gui.PROP_COLOR, WHITE_COLOR, gui.EASING_OUTCIRC, 0.5, 0)
		end
	end)
	self.next_question:disable()
	self.answers = {}

	self.pers = {
		[1] = {
			root = gui.get_node('bride'),
			face = gui.get_node('bride_face'),
			pos = gui.get_position(gui.get_node('bride'))
		},
		[2] = {
			root = gui.get_node('groom'),
			face = gui.get_node('groom_face'),
			pos = gui.get_position(gui.get_node('groom'))
		}
	}
	
	for i = 1, 4 do
		local answer_index = i
		self.answers[i] = {
			button = button.new(nil, 'answer_' .. i, function()
				if self.answers[i].picked then
					self.answers[i].button:shake()
				else
					on_answer(self, answer_index)
				end
				
			end),
			icon = gui.get_node('answer_icon_' .. i),
			text = gui.get_node('answer_text_' .. i)
		}
	end
end

function init(self)
	gui.set_render_order(3)
	msg.post('.', 'acquire_input_focus')
	self.questions = victorina.get_questions()
	self.question_index = 1
	self.question = self.questions[self.question_index]
	self.side = 1
	self.score = {
		[1] = 0,
		[2] = 0
	}
	self.attempt = 1
	init_nodes(self)
	show_question(self)
	set_score(self)
	set_default(self)
end

function on_input(self, action_id, action)
	for index, answer in ipairs(self.answers) do
		if answer.button:on_input(action) then
			return true
		end
	end

	if self.next_question:on_input(action) then
		return true
	end
end

